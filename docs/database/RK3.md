# Домашнее задание 3. Администрирование СУБД

## Безопасность сервера СУБД

### Работа с БД через сервисную учетную запись

Создан [скрипт](./../../scripts/create_app_user.sql) добавления пользователя базы данных.

Этот скрипт создает пользователя базы данных с именем и паролем, заданными в переменных окружения
APP_DB_USER и APP_DB_PASSWORD соответственно.

Поскольку этот скрипт является не является частью бизнес логики приложения, он
находится не в папке с миграциями или непосредственно тестовыми данными, а в папке [scripts](./../../scripts).

Данные пользователя и администратора задаются в [.env](./../../.env.example)

Скрипт запускается автоматически при выполнении команды `make all-prepare` или `make db-create-app-user`.
(см.[Makefile](./../../Makefile))

### Защита от SQL инъекций

Все SQL запросы в приложении выполняются с использованием подготовленных выражений (prepared statements),
что защищает приложение от SQL инъекций. См любый [пример](./../../internal/adapter/postgres/) запроса.

Также можно протестировать защиту от SQL инъекций с помощью инструмента [sqlmap](https://sqlmap.org/).
Но я считаю, что это излишне, т.к. подготовленные выражения в сумме со стандартной библиотекой go уже обеспечивают надежную защиту.

```bash
sudo apt install sqlmap
cd scripts
chmod +x sqlmap.sh
./sqlmap.sh
```

### Пул соединений и параметры соединений

В приложении настроен пул соединений к базе данных с помощью стандартной библиотеки `database/sql`.

См. [настройки пула соединений](./../../internal/adapter/postgres/database.go#L39-L44).

Параметры пула соединений задаются в файле [.env](./../../.env.example):

- DB_POOL_MAX_OPEN - максимальное количество открытых соединений к базе данных
- DB_POOL_MAX_IDLE - максимальное количество неиспользуемых соединений в пуле
- DB_POOL_CONN_MAX_LIFETIME_MIN - максимальное время жизни соединения в минутах

max_connections и listen_addresses в Postgres настроены в файле [postgres.conf](./../../postgres.conf#L118-L124)

#### Обоснование выбора количества соединений

В нашем проекте используется три приложения, каждое из которых настраивает пул соединений с максимальным количеством 5 (`DB_POOL_MAX_OPEN=5`). Таким образом, в худшем случае суммарное количество одновременных соединений к базе данных составит 15.

Для обеспечения стабильной работы базы данных и учета возможных дополнительных соединений (например, для административных задач), мы устанавливаем параметр `max_connections` в Postgres равным 20.

Такой выбор обусловлен следующими соображениями:

- **Балансировка нагрузки**: Количество соединений в пуле должно быть достаточно большим, чтобы обеспечить параллельную обработку запросов, но не превышать разумные пределы, чтобы не перегружать сервер базы данных.
- **max_connections в Postgres**: Значение параметра `max_connections` в Postgres должно быть не меньше суммарного количества соединений всех приложений плюс небольшой запас для административных задач и возможных дополнительных сервисов.
- **Экономия ресурсов**: Избыточное количество соединений приводит к увеличению потребления памяти и снижению производительности СУБД. Поэтому важно не задавать слишком большие значения ни в пуле, ни в настройках Postgres.

#### Обоснование выбора параметра listen_addresses

Параметр `listen_addresses` в Postgres определяет, на каких сетевых интерфейсах сервер базы данных будет принимать входящие соединения. В нашем проекте мы устанавливаем `listen_addresses` в значение `*`, что означает, что сервер будет слушать на всех доступных интерфейсах. Такой выбор обусловлен тем что наше приложение разворачивается в Docker-контейнерах, и для обеспечения связи между контейнерами (например, между приложениями и базой данных) необходимо, чтобы Postgres принимал соединения на всех интерфейсах. Причем с точки зрения безопасности, доступ к базе данных ограничен внутренней сетью Docker, что минимизирует риски несанкционированного доступа извне.

## Настройка параметров сервера и клиента

### Таймауты

В файле [scripts/create_app_user.sql](./../../scripts/create_app_user.sql) добавлены настройки таймаутов на уровне роли приложения:

```sql
-- Таймауты на уровне роли приложения
ALTER ROLE :"app_user" SET statement_timeout = '2s';
ALTER ROLE :"app_user" SET lock_timeout = '200ms';
```

Эти настройки обеспечивают, что любые SQL-запросы, выполняемые от имени пользователя приложения, будут прерваны, если они выполняются дольше 2 секунд (`statement_timeout`) или если они не могут получить блокировку в течение 200 миллисекунд (`lock_timeout`).

Приложение Popfilms не предполагает длительных транзакций или долгих запросов к базе данных, поэтому такие таймауты помогают избежать зависаний и обеспечивают более отзывчивую работу приложения.

### Логгирование и протоколирование медленных запросов

В файле [postgres.conf](./../../postgres.conf) настроено логгирование медленных запросов:

```conf
# Логгирование медленных запросов
log_min_duration_statement = 1000  # Логгировать запросы, выполняющиеся дольше 1000 мс

# auto_explain
auto_explain.log_min_duration = 200ms
auto_explain.log_analyze      = on

# pg_stat_statements
pg_stat_statements.track = all
```

#### Генерация отчета с помощью pgbadger

```bash
make db-badger
```

### Мониторинг нагрузки на сервер

Для мониторинга нагрузки на сервер используется postgres_exporter, который собирает метрики из базы данных и предоставляет их в формате, совместимом с Prometheus.

Для визуализации метрик используется Grafana, которая позволяет строить [дашборд 1](https://grafana.com/grafana/dashboards/12485-postgresql-exporter/) и [дашборд 2](https://grafana.com/grafana/dashboards/12273-postgresql-overview-postgres-exporter/) и [дашбоард 3](https://grafana.com/grafana/dashboards/3742-aaa-postgres-exporter/) для мониторинга производительности базы данных.

Замечу, что некоторые значения параметров могут отличаться, так как дашборды старые.

> Для имитации нагрузки на сервер (предварительно изменив BASE_URL на localhost) можно использовать [scripts/smoke](./../../scripts/smoke.sh) или [scripts/stress](./../../scripts/stress.sh).
